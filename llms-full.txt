# AbstractUIC (llms-full)

> Generated file. Do not edit by hand; run `python scripts/generate-llms-full.py`.

## README.md

# AbstractUIC

Reusable UI packages for AbstractFramework clients (React components + a small Web Component).

> Packages are ESM and ship CSS alongside JS. See `docs/getting-started.md` for required CSS imports and Next.js notes.

## Documentation

- Getting started (entrypoint): [`docs/getting-started.md`](./docs/getting-started.md)
- API reference: [`docs/api.md`](./docs/api.md)
- FAQ: [`docs/faq.md`](./docs/faq.md)
- Architecture (includes diagrams): [`docs/architecture.md`](./docs/architecture.md)
- Docs index: [`docs/README.md`](./docs/README.md)
- Changelog: [`CHANGELOG.md`](./CHANGELOG.md) (alias: `CHANGELOD.md`)
- Contributing: [`CONTRIBUTING.md`](./CONTRIBUTING.md)
- Security: [`SECURITY.md`](./SECURITY.md)
- Acknowledgments: [`ACKNOWLEDMENTS.md`](./ACKNOWLEDMENTS.md)

## Packages

| Package | Purpose | Docs |
|---|---|---|
| `@abstractframework/ui-kit` | Theme tokens (CSS variables) + small UI primitives (selects/icons) | [`ui-kit/README.md`](./ui-kit/README.md) |
| `@abstractframework/panel-chat` | Chat thread + message cards + composer + markdown/json rendering | [`panel-chat/README.md`](./panel-chat/README.md) |
| `@abstractframework/monitor-flow` | Agent-cycle trace viewer + ledger adapter | [`monitor-flow/README.md`](./monitor-flow/README.md) |
| `@abstractframework/monitor-active-memory` | Knowledge Graph + Active Memory explorer (ReactFlow) | [`monitor-active-memory/README.md`](./monitor-active-memory/README.md) |
| `@abstractframework/monitor-gpu` | GPU utilization widget (`<monitor-gpu>`) polling a metrics endpoint | [`monitor-gpu/README.md`](./monitor-gpu/README.md) |

## Context

[AbstractFramework](https://github.com/lpalbou/abstractframework) is a workflow/runtime system with multiple host UX layers. AbstractUIC packages are host-driven UI building blocks used by those clients (no host imports; data + callbacks flow in from the host).

## Install

Packages are published independently. Install only the package(s) you need (once published):

```bash
# chat
npm i @abstractframework/panel-chat @abstractframework/ui-kit

# agent traces
npm i @abstractframework/monitor-flow

# active memory explorer (requires reactflow peer dep)
npm i @abstractframework/monitor-active-memory reactflow

# gpu widget (web component)
npm i @abstractframework/monitor-gpu
```

## Quickstart (React)

See [`docs/getting-started.md`](./docs/getting-started.md) for bundler + CSS notes. Minimal usage:

```tsx
import "@abstractframework/ui-kit/theme.css";
import "@abstractframework/panel-chat/panel_chat.css";
import "@abstractframework/monitor-flow/agent_cycles.css";
import "@abstractframework/monitor-active-memory/styles.css";
// Only if you use @abstractframework/monitor-active-memory (ReactFlow):
import "reactflow/dist/style.css";

import { ChatThread } from "@abstractframework/panel-chat";
import { AgentCyclesPanel } from "@abstractframework/monitor-flow";
import { KgActiveMemoryExplorer } from "@abstractframework/monitor-active-memory";
```

## Development

- Install + build workspaces: `npm install && npm run build`
- Run tests: `npm test` (only `@abstractframework/monitor-gpu` currently ships automated tests)
- React packages are typically validated via a host app that links them in a workspace (HMR).

See [`docs/development.md`](./docs/development.md).

## License

MIT (see [`LICENSE`](./LICENSE)).

## docs/getting-started.md

# Getting Started

AbstractUIC is a small set of **UI packages** (React components + one Web Component). Each top-level folder in this repo is an independently-consumable package.

If you’re new here, you typically:

1. Pick the package(s) you need
2. Install them (from npm, or from source/workspaces)
3. Import the required CSS (theme tokens + per-package styles; and ReactFlow styles if applicable)

For a package-by-package export map, see the [API reference](./api.md).

## Pick a package

| Package | Use when you need… | Primary exports (source of truth) |
|---|---|---|
| `@abstractframework/ui-kit` | Shared theme tokens + small UI primitives (selects/icons) | `ui-kit/src/index.ts` |
| `@abstractframework/panel-chat` | Chat thread + message UI + markdown/json rendering | `panel-chat/src/index.ts` |
| `@abstractframework/monitor-flow` | Agent “cycles” trace viewer + ledger adapter | `monitor-flow/src/index.ts` |
| `@abstractframework/monitor-active-memory` | Knowledge Graph + Active Memory explorer (ReactFlow) | `monitor-active-memory/src/index.ts` |
| `@abstractframework/monitor-gpu` | GPU utilization histogram widget (`<monitor-gpu>`) | `monitor-gpu/src/index.js` |

## Requirements

- React packages declare `react@^18` and `react-dom@^18` as peer dependencies (see each `*/package.json`).
- `@abstractframework/monitor-active-memory` also declares `reactflow@^11` as a peer dependency.
- Packages are ESM (`"type": "module"`). In web apps, use a bundler that can consume ESM and CSS.

## Install / integrate

Packages are designed to be installed **individually** (install only what you need). Common options:

- **npm** (recommended for external consumers): install the package(s) you need once published.
- **Workspace / source**: add this repo as a workspace in your host app, or vendor the package folder(s).
  - Workspace: build the packages you change (`npm run build`, see [Development](./development.md)).
  - Vendored sources: if you consume TypeScript sources directly, your toolchain must transpile TS/TSX dependencies.

Maintainers: see [Publishing](./publishing.md).

### Install from npm (once published)

Install only what you need:

```bash
# chat
npm i @abstractframework/panel-chat @abstractframework/ui-kit

# agent traces
npm i @abstractframework/monitor-flow

# active memory explorer (requires reactflow peer dep)
npm i @abstractframework/monitor-active-memory reactflow

# gpu widget (web component)
npm i @abstractframework/monitor-gpu
```

## CSS you must import

Import theme tokens once (recommended):

```ts
import "@abstractframework/ui-kit/theme.css";
```

Import per-package styles for the packages you use:

```ts
import "@abstractframework/panel-chat/panel_chat.css";
import "@abstractframework/monitor-flow/agent_cycles.css";
import "@abstractframework/monitor-active-memory/styles.css";
```

If you use `@abstractframework/monitor-active-memory`, also import ReactFlow base styles in your app:

```ts
import "reactflow/dist/style.css";
```

## Quick examples

### Chat (`@abstractframework/panel-chat`)

```tsx
import React, { useState } from "react";
import { ChatComposer, ChatThread, type ChatMessage } from "@abstractframework/panel-chat";

export function ChatView() {
  const [value, setValue] = useState("");
  const [messages, setMessages] = useState<ChatMessage[]>([]);

  return (
    <>
      <ChatThread messages={messages} autoScroll />
      <ChatComposer
        value={value}
        onChange={setValue}
        onSubmit={() => {
          const content = value.trim();
          if (!content) return;
          setMessages((m) => [...m, { role: "user", content }]);
          setValue("");
        }}
      />
    </>
  );
}
```

### Agent cycles (`@abstractframework/monitor-flow`)

```tsx
import { AgentCyclesPanel, build_agent_trace } from "@abstractframework/monitor-flow";

const { items } = build_agent_trace(ledgerItems, { run_id: "run_123" });
<AgentCyclesPanel items={items} />;
```

Cycles are segmented when `step.effect.type === "llm_call"` (see `monitor-flow/src/AgentCyclesPanel.tsx`).

### Active Memory explorer (`@abstractframework/monitor-active-memory`)

```tsx
import { KgActiveMemoryExplorer, type KgAssertion } from "@abstractframework/monitor-active-memory";

const items: KgAssertion[] = [];

<KgActiveMemoryExplorer
  items={items}
  onQuery={async (params) => {
    // Host decides how to fetch/search KG assertions.
    return { ok: true, items: [], active_memory_text: "" };
  }}
/>;
```

### GPU widget (`@abstractframework/monitor-gpu`)

```js
import { registerMonitorGpuWidget } from "@abstractframework/monitor-gpu";

registerMonitorGpuWidget();
const el = document.createElement("monitor-gpu");
el.baseUrl = "http://localhost:8080"; // optional; defaults to same-origin
el.token = "your-gateway-token"; // or: el.getToken = async () => "..."
el.tickMs = 1500;
el.historySize = 20;
el.mode = "icon"; // "full" | "icon"
document.body.appendChild(el);
```

## Next.js notes

- Import global CSS from your app entrypoint (e.g. `app/layout.tsx` or `pages/_app.tsx`), not from deep component files.
- Client-only: several components touch browser APIs (`window`, `document`, `navigator`, `localStorage`). Render them in client components.
- If you consume TypeScript sources directly (workspace/vendored), Next.js may need `transpilePackages`.

```js
// next.config.js
module.exports = {
  transpilePackages: ["@abstractframework/ui-kit", "@abstractframework/panel-chat", "@abstractframework/monitor-flow", "@abstractframework/monitor-active-memory"],
};
```

## Next docs

- [API reference](./api.md)
- [FAQ](./faq.md)
- [Architecture](./architecture.md)
- [Development](./development.md)
- [Publishing (maintainers)](./publishing.md)

## docs/api.md

# API Reference

This page is a **practical map** of what each package exports and how you typically integrate it.

Source of truth:
- React packages: exports in `*/src/index.ts` (compiled to `dist/` on publish; see `*/package.json`)
- GPU widget: exports in `monitor-gpu/src/index.js` (types in `monitor-gpu/src/index.d.ts`)

If you’re starting from scratch, read [Getting started](./getting-started.md) first (it covers install options and required CSS imports).

## Shared integration notes (React packages)

- All React packages are ESM (`"type": "module"`) and declare `react@^18` / `react-dom@^18` as peer dependencies (see each `*/package.json`).
- **CSS is shipped as a separate export and must be imported by the host app** (do this in your app entrypoint, especially for Next.js).

CSS entrypoints (files live in each package’s `src/`):

```ts
import "@abstractframework/ui-kit/theme.css";
import "@abstractframework/panel-chat/panel_chat.css";
import "@abstractframework/monitor-flow/agent_cycles.css";
import "@abstractframework/monitor-active-memory/styles.css";
import "reactflow/dist/style.css"; // only when using monitor-active-memory
```

## `@abstractframework/ui-kit`

Purpose: shared **theme tokens** + small UI primitives used by other packages and host apps.

- Primary exports: `ui-kit/src/index.ts`
- CSS: `@abstractframework/ui-kit/theme.css` (file: `ui-kit/src/theme.css`)

Key exports:
- Theme: `THEMES`, `THEME_SPECS`, `applyTheme()`, `getThemeSpec()`, `themeClassName()`
- Typography: `FONT_SCALES`, `HEADER_DENSITIES`, `applyTypography()`, `getFontScaleSpec()`, `getHeaderDensitySpec()`
- Inputs: `AfSelect`, `ThemeSelect`, `ProviderModelSelect`, `FontScaleSelect`, `HeaderDensitySelect`
- Icons: `Icon`, `IconName`

See: [`ui-kit/README.md`](../ui-kit/README.md).

## `@abstractframework/panel-chat`

Purpose: chat-thread UI primitives with lightweight Markdown/JSON rendering.

- Primary exports: `panel-chat/src/index.ts`
- CSS: `@abstractframework/panel-chat/panel_chat.css` (file: `panel-chat/src/panel_chat.css`)

Components:
- `ChatThread` (thread container; renders a list of messages)
- `ChatMessageCard` (single message rendering)
- `ChatMessageContent` (message body renderer; JSON autodetect + Markdown)
- `ChatComposer` (composer input + submit handling)

Renderers:
- `Markdown` (minimal Markdown rendering; see `panel-chat/src/markdown.tsx`)
- `JsonViewer`

Types:
- `PanelChatMessage` (generic message model used by `ChatThread`)
- `ChatMessage`, `ChatAttachment`, `ChatMessageLevel`, `ChatStat` (see `panel-chat/src/chat_message_card.tsx`)

Utilities:
- `tryParseJson()` (drives JSON autodetection in `ChatMessageContent`)
- `chatToMarkdown()`, `copyText()`, `downloadTextFile()`

Customization point:
- `ChatMessageContent` supports `renderMarkdown?: (markdown: string) => React.ReactElement` (see `panel-chat/src/message_content.tsx`).

See: [`panel-chat/README.md`](../panel-chat/README.md) and [FAQ](./faq.md) (search for “panel-chat”).

## `@abstractframework/monitor-flow`

Purpose: inspect **agent execution cycles** from trace/ledger-like records.

- Primary exports: `monitor-flow/src/index.ts`
- CSS: `@abstractframework/monitor-flow/agent_cycles.css` (file: `monitor-flow/src/agent_cycles.css`)

Components:
- `AgentCyclesPanel` (main UI)

Types:
- `TraceItem`, `TraceStep` (see `monitor-flow/src/AgentCyclesPanel.tsx`)

Adapter:
- `build_agent_trace(ledgerItems, { run_id })` to turn “ledger-like” items into `TraceItem[]` (see `monitor-flow/src/agent_cycles_adapter.ts`)
- Types: `LedgerRecordItem`, `StepRecordLike`, `AgentTraceBuildResult`

See: [`monitor-flow/README.md`](../monitor-flow/README.md) and [Architecture](./architecture.md) for the host-driven data flow.

## `@abstractframework/monitor-active-memory`

Purpose: ReactFlow-based explorer for **Knowledge Graph assertions** (`KgAssertion`) and derived **Active Memory** text.

- Primary exports: `monitor-active-memory/src/index.ts`
- CSS: `@abstractframework/monitor-active-memory/styles.css` (file: `monitor-active-memory/src/styles.css`)
- Peer dep: `reactflow@^11` (see `monitor-active-memory/package.json`)

Component:
- `KgActiveMemoryExplorer` (+ `KgActiveMemoryExplorerProps`)

Host contracts:
- Types: `KgAssertion`, `KgQueryParams`, `KgQueryResult`, `MemoryScope`, `RecallLevel` (see `monitor-active-memory/src/types.ts`)
- The component calls `onQuery(params)` when the user runs a query / expands neighborhoods (see `monitor-active-memory/src/KgActiveMemoryExplorer.tsx`).

Graph/layout utilities (for advanced hosts):
- `buildKgGraph()`, `shortestPath()`, `buildKgLayout()`
- Force simulation helpers: `initForceSimulation()`, `stepForceSimulation()`, `forceSimulationEnergy()`, `forceSimulationPositions()`

See: [`monitor-active-memory/README.md`](../monitor-active-memory/README.md) and [FAQ](./faq.md) (search for “monitor-active-memory”).

## `@abstractframework/monitor-gpu`

Purpose: dependency-free GPU utilization widget implemented as a **Custom Element**.

- Primary exports: `monitor-gpu/src/index.js`
- Types: `monitor-gpu/src/index.d.ts`

Registration + custom element:
- `registerMonitorGpuWidget()` defines `<monitor-gpu>` (see `monitor-gpu/src/monitor_gpu_widget.js`)
- `MonitorGpuElement` typing is declared in `monitor-gpu/src/index.d.ts` (includes `mode: "full" | "icon"`)

Imperative controller:
- `createMonitorGpuWidget(target, options)` returns `MonitorGpuWidgetController` (start/stop/destroy; update options)

Low-level helpers (backend integration):
- `makeGpuMetricsUrl()`, `fetchHostGpuMetrics()`
- `buildAuthHeaders()`, `resolveBearerToken()`
- `extractUtilizationGpuPct(payload)` (supported payload formats documented in `monitor-gpu/README.md`)

See: [`monitor-gpu/README.md`](../monitor-gpu/README.md) for the backend contract and security notes.

## Related docs

- Getting started: [Getting started](./getting-started.md)
- FAQ: [FAQ](./faq.md)
- Architecture (diagrams): [Architecture](./architecture.md)
- Docs index: [Docs index](./README.md)
- Security policy: [`SECURITY.md`](../SECURITY.md)

## docs/faq.md

# FAQ

This FAQ is written for first-time users integrating AbstractUIC packages into a host app. The **source of truth is the code** (exports in `*/src/index.*` and contracts/types in `src/`).

## Contents

- [What is AbstractUIC?](#what-is-abstractuic)
- [Which package should I use?](#which-package-should-i-use)
- [Do I install a single package or multiple?](#do-i-install-a-single-package-or-multiple)
- [Why do I need a bundler / transpilation?](#why-do-i-need-a-bundler--transpilation)
- [Do you support Next.js?](#do-you-support-nextjs)
- [Do I need to import CSS manually?](#do-i-need-to-import-css-manually)
- [Are these components SSR-safe?](#are-these-components-ssr-safe)
- [How do I theme the UI?](#how-do-i-theme-the-ui)
- [panel-chat: How do I plug in my own Markdown renderer?](#panel-chat-how-do-i-plug-in-my-own-markdown-renderer)
- [panel-chat: How is JSON detected?](#panel-chat-how-is-json-detected)
- [monitor-flow: What trace format does AgentCyclesPanel expect?](#monitor-flow-what-trace-format-does-agentcyclespanel-expect)
- [monitor-active-memory: How does querying work?](#monitor-active-memory-how-does-querying-work)
- [monitor-active-memory: Does it persist layouts?](#monitor-active-memory-does-it-persist-layouts)
- [monitor-gpu: What backend payload does it expect?](#monitor-gpu-what-backend-payload-does-it-expect)
- [monitor-gpu: How do I set auth and CORS safely?](#monitor-gpu-how-do-i-set-auth-and-cors-safely)
- [Where are the tests?](#where-are-the-tests)
- [Is this published to npm?](#is-this-published-to-npm)

## What is AbstractUIC?

AbstractUIC is a **multi-package repository**: each top-level folder is an npm package (see each `*/package.json`). Most packages are React components; one package (`@abstractframework/monitor-gpu`) is a dependency-free Web Component.

Start here: [Getting started](./getting-started.md).

See also:
- API reference: [API reference](./api.md)
- Architecture (diagrams): [Architecture](./architecture.md)

## Which package should I use?

Use the table in [Getting started](./getting-started.md) to pick a package by use-case.

Authoritative exports:

- `@abstractframework/ui-kit`: `ui-kit/src/index.ts`
- `@abstractframework/panel-chat`: `panel-chat/src/index.ts`
- `@abstractframework/monitor-flow`: `monitor-flow/src/index.ts`
- `@abstractframework/monitor-active-memory`: `monitor-active-memory/src/index.ts`
- `@abstractframework/monitor-gpu`: `monitor-gpu/src/index.js`

## Do I install a single package or multiple?

Packages are meant to be installed individually — install only what you need.

Common combos:

- Chat UI: `@abstractframework/panel-chat` + `@abstractframework/ui-kit` (icons + shared tokens)
- Monitoring: `@abstractframework/monitor-flow` + `@abstractframework/ui-kit`
- KG explorer: `@abstractframework/monitor-active-memory` (+ `reactflow` peer dependency)

## Why do I need a bundler / transpilation?

All packages are ESM (`"type": "module"`). In web apps, you typically use a bundler to handle ESM and CSS imports.

If you consume TypeScript sources directly (vendored source), your toolchain must also transpile TS/TSX dependencies (example for Next.js: `transpilePackages`, see [Getting started](./getting-started.md)).

## Do you support Next.js?

Yes. In practice:

- import global CSS from your app entrypoint (`app/layout.tsx` or `pages/_app.tsx`)
- client-only rendering for DOM-dependent components (see SSR question below)
- if you consume TypeScript sources directly, use `transpilePackages` (see [Getting started](./getting-started.md))

## Do I need to import CSS manually?

Usually yes:

- Import theme tokens once (recommended): `import "@abstractframework/ui-kit/theme.css";` (file: `ui-kit/src/theme.css`)
- Import per-package styles for the packages you use:
  - `import "@abstractframework/panel-chat/panel_chat.css";`
  - `import "@abstractframework/monitor-flow/agent_cycles.css";`
  - `import "@abstractframework/monitor-active-memory/styles.css";`
- If you use `@abstractframework/monitor-active-memory`, import ReactFlow base styles in your app: `import "reactflow/dist/style.css";`

See: [Getting started](./getting-started.md).

## Are these components SSR-safe?

Not universally.

Several components/utilities reference browser APIs such as `window`, `document`, `navigator`, or `localStorage` (examples: copy-to-clipboard helpers, layout persistence, DOM measurements). In SSR frameworks, render these components client-side (or behind dynamic import / “use client” boundaries).

## How do I theme the UI?

1. Import tokens once: `@abstractframework/ui-kit/theme.css`
2. Choose a theme class (e.g. `theme-dark`, `theme-light`, `theme-catppuccin-mocha`, …) or call the helper:

```ts
import { applyTheme } from "@abstractframework/ui-kit";

applyTheme("dark"); // applies a `theme-*` class to <html>
```

See: `ui-kit/src/theme.ts` and `ui-kit/src/theme.css`.

## panel-chat: How do I plug in my own Markdown renderer?

Use `renderMarkdown` on `ChatMessageContent` (or pass it through `ChatMessageCard` via `messageProps` in `ChatThread`).

Source of truth: `panel-chat/src/message_content.tsx` (`renderMarkdown?: (markdown: string) => React.ReactElement`).

## panel-chat: How is JSON detected?

`ChatMessageContent` calls `tryParseJson(text)` and renders:

- JSON ⇒ `JsonViewer`
- otherwise ⇒ `Markdown` (or `renderMarkdown` override)

Source of truth: `panel-chat/src/message_content.tsx` and `panel-chat/src/utils.ts`.

## monitor-flow: What trace format does AgentCyclesPanel expect?

`AgentCyclesPanel` consumes `TraceItem[]` and starts a new cycle when `step.effect.type === "llm_call"`.

Source of truth:

- `monitor-flow/src/AgentCyclesPanel.tsx` (types + cycle segmentation)
- `monitor-flow/src/agent_cycles_adapter.ts` (`build_agent_trace(...)` to adapt ledger-like records)

## monitor-active-memory: How does querying work?

Querying is host-driven:

- Provide `onQuery(params: KgQueryParams) => Promise<KgQueryResult>`
- The component calls it when the user runs a query or expands a neighborhood

Source of truth: `monitor-active-memory/src/KgActiveMemoryExplorer.tsx` (`onQuery`, `queryMode`, `onItemsReplace`).

## monitor-active-memory: Does it persist layouts?

Yes (in the browser): per-view layouts can be saved to `localStorage` under key `abstractuic_amx_saved_layouts_v1`.

Source of truth: `monitor-active-memory/src/KgActiveMemoryExplorer.tsx`.

## monitor-gpu: What backend payload does it expect?

The widget treats the payload as “supported” unless `supported === false` and extracts utilization via `extractUtilizationGpuPct(payload)`:

- `payload.utilization_gpu_pct` (number) **or**
- `payload.gpus[][].utilization_gpu_pct` (numbers; averaged)

Source of truth: `monitor-gpu/src/gpu_metrics_api.js` and `monitor-gpu/src/monitor_gpu_widget.js`.

## monitor-gpu: How do I set auth and CORS safely?

- Provide auth via `el.token = "..."` or `el.getToken = async () => "..."` (the widget sends `Authorization: Bearer <token>`)
- Do not pass tokens in URLs
- For cross-origin usage, configure your backend’s allowed origins (see security notes in `monitor-gpu/README.md`)

Source of truth: `monitor-gpu/src/gpu_metrics_api.js` (`buildAuthHeaders`) and `monitor-gpu/src/monitor_gpu_widget.js`.

## Where are the tests?

Only `@abstractframework/monitor-gpu` currently includes automated tests:

```bash
cd monitor-gpu
npm test
```

See: `monitor-gpu/test/`.

## Is this published to npm?

Each package is an npm package (has its own `package.json`). Whether a package is available on npm depends on your release process.

Maintainers: see [Publishing](./publishing.md).

## Related docs

- Docs index: [Docs index](./README.md)
- Getting started: [Getting started](./getting-started.md)
- API reference: [API reference](./api.md)
- Architecture: [Architecture](./architecture.md)

## docs/architecture.md

# Architecture

AbstractUIC is a **multi-package repository**: each folder at the repo root is an independently-consumable package.

This document stays intentionally close to the code: every claim below is backed by a package entrypoint, type definition, or runtime contract in `src/`.

## High-level overview

- **React packages** ship **compiled ESM + type declarations** from `dist/` (see `exports` in each `package.json`). Source lives in `src/` and is built with `tsc`.
- **`@abstractframework/monitor-gpu`** ships **JavaScript** (`monitor-gpu/src`) and registers a custom element.
- Styling is shipped as plain CSS and exposed as package exports (e.g. `@abstractframework/panel-chat/panel_chat.css`).

## Package dependency graph

```mermaid
flowchart LR
  subgraph AbstractUIC
    UIKIT["@abstractframework/ui-kit"]
    CHAT["@abstractframework/panel-chat"]
    FLOW["@abstractframework/monitor-flow"]
    AMX["@abstractframework/monitor-active-memory"]
    GPU["@abstractframework/monitor-gpu"]
  end

  CHAT -->|"imports Icon"| UIKIT
  AMX -->|"peer dep"| ReactFlow["reactflow (peer dependency)"]
  FLOW -->|"peer dep"| React["react / react-dom (peer dependency)"]
  CHAT -->|"peer dep"| React
  UIKIT -->|"peer dep"| React
```

Evidence:
- `panel-chat/src/chat_message_card.tsx` imports `Icon` from `@abstractframework/ui-kit`.
- `monitor-active-memory/package.json` declares `reactflow` as a peer dependency.

## Runtime data flow

AbstractUIC components are designed to be **host-driven**: hosts provide data and callbacks; the packages do not import host code.

```mermaid
flowchart TD
  Host["Host app (AbstractFlow / AbstractObserver / etc.)"]

  Host -->|"TraceItem[] (or build_agent_trace)"| FlowPanel["monitor-flow: AgentCyclesPanel"]
  Host -->|"KgAssertion[] + onQuery() (optional)"| AMXPanel["monitor-active-memory: KgActiveMemoryExplorer"]
  Host -->|"ChatMessage[] + callbacks"| ChatUI["panel-chat: ChatThread / ChatComposer / ChatMessageCard"]

  Host -->|"register + attach <monitor-gpu>"| GPUWidget["monitor-gpu: <monitor-gpu>"]
  GPUWidget -->|"GET /api/gateway/host/metrics/gpu"| Metrics["Gateway / metrics endpoint"]
```

Evidence:
- `monitor-flow/src/AgentCyclesPanel.tsx` consumes `TraceItem[]` and groups cycles by `step.effect.type === "llm_call"`.
- `monitor-flow/src/agent_cycles_adapter.ts` exports `build_agent_trace(...)` to adapt ledger-like records into `TraceItem[]`.
- `monitor-active-memory/src/KgActiveMemoryExplorer.tsx` consumes `items: KgAssertion[]` and optionally calls `onQuery(params)`.
- `monitor-gpu/src/gpu_metrics_api.js` builds/fetches the metrics URL and attaches Bearer auth headers.

## Contracts & types (what you pass in)

### Knowledge graph / active memory (`monitor-active-memory`)

- `KgAssertion` / `KgQueryParams` / `KgQueryResult`: `monitor-active-memory/src/types.ts`
- Graph utilities: `monitor-active-memory/src/graph.ts`
- Main component + callback contracts: `monitor-active-memory/src/KgActiveMemoryExplorer.tsx`

### Agent traces (`monitor-flow`)

- `TraceItem` / `TraceStep`: `monitor-flow/src/AgentCyclesPanel.tsx`
- Ledger adapter: `monitor-flow/src/agent_cycles_adapter.ts`

### Chat (`panel-chat`)

- `ChatMessage`, `ChatAttachment`, `ChatStat`: `panel-chat/src/chat_message_card.tsx`
- `ChatThread` / `ChatComposer`: `panel-chat/src/chat_thread.tsx`, `panel-chat/src/chat_composer.tsx`

### GPU metrics (`monitor-gpu`)

The widget expects JSON that can be interpreted by `extractUtilizationGpuPct(payload)`:

- `payload.utilization_gpu_pct` (number) **or**
- `payload.gpus[][].utilization_gpu_pct` (numbers; averaged)

See: `monitor-gpu/src/gpu_metrics_api.js` and `monitor-gpu/src/monitor_gpu_widget.js`.

## Styling & theming

- `@abstractframework/ui-kit` provides CSS variables + theme classes in `ui-kit/src/theme.css` (exported as `@abstractframework/ui-kit/theme.css`).
- Other packages use those variables where available, but include fallbacks (e.g. `var(--ui-border-1, rgba(...))`).

See also: [Getting started](./getting-started.md) for integration + required CSS.

## Related docs

- Getting started: [Getting started](./getting-started.md)
- API reference: [API reference](./api.md)
- FAQ: [FAQ](./faq.md)
- Docs index: [Docs index](./README.md)
- Development: [Development](./development.md)
- Package docs: see the table in the root [`README.md`](../README.md)

## docs/development.md

# Development

This repo is intentionally lightweight. Most React packages build with `tsc` into `dist/` (see `*/package.json` scripts).

## Repo layout

Each package is a folder at the repo root:

- `ui-kit/`
- `panel-chat/`
- `monitor-flow/`
- `monitor-active-memory/`
- `monitor-gpu/`

## Typical workflow (React packages)

1. Install workspace deps at the repo root (workspaces): `npm install`
2. Build the package(s) you’re editing:
   - one-off: `cd <package> && npm run build`
   - watch: `cd <package> && npm run build -- --watch`
3. Consume the package from your host app (workspace link / file dependency / published package) and validate behavior.

## Tests

Only `@abstractframework/monitor-gpu` currently has automated tests:

```bash
cd monitor-gpu
npm test
```

## Docs (when you change behavior)

- Keep docs anchored to the code (exports in `*/src/index.*`, contracts in `src/`).
- If you changed documentation, regenerate `llms-full.txt`:

```bash
python scripts/generate-llms-full.py
```

## Related docs

- Contributing: [`CONTRIBUTING.md`](../CONTRIBUTING.md)
- Getting started: [Getting started](./getting-started.md)
- Architecture: [Architecture](./architecture.md)
- Docs index: [Docs index](./README.md)

## docs/publishing.md

# Publishing (Maintainers)

Each folder is an npm package and can be published independently.

## Pre-flight

- Ensure README + docs links are correct (root `README.md` + per-package `README.md`).
- Ensure `repository` metadata points to this repo (`https://github.com/lpalbou/AbstractUIC`).
- Ensure peer dependency ranges are valid semver (avoid `workspace:*` in published metadata).
- Ensure `dist/` is produced (React packages build via `tsc`; see each package’s `prepublishOnly`).

## Suggested release steps

1. Bump versions in each `*/package.json` you plan to publish (this repo currently keeps versions in sync).
1. Update [`CHANGELOG.md`](../CHANGELOG.md) with what changed.
1. Install workspace deps at repo root: `npm install`
1. Build packages (optional preflight): `npm run build`
1. Run package tests:
   - `cd monitor-gpu && npm test`
1. Dry-run the package tarball (optional): `npm pack` inside each package.
1. Publish from the package directory:

```bash
cd <package>
npm publish --access public
```

Notes:
- Scoped packages are private by default; `--access public` is required for public release.
- React packages publish compiled output from `dist/` and expose CSS as separate exports (see each package’s `exports`).

## Related docs

- Changelog: [`CHANGELOG.md`](../CHANGELOG.md)
- Contributing: [`CONTRIBUTING.md`](../CONTRIBUTING.md)
- Getting started: [Getting started](./getting-started.md)
- Architecture: [Architecture](./architecture.md)

## docs/README.md

# AbstractUIC Documentation

This repository is a small set of **UI packages** (React components + one Web Component).

## Start here

- **Getting started**: [`getting-started.md`](./getting-started.md)
- **API reference**: [`api.md`](./api.md)
- **FAQ**: [`faq.md`](./faq.md)
- **Architecture + package boundaries**: [`architecture.md`](./architecture.md)
- **Local development**: [`development.md`](./development.md)
- **Publishing (maintainers)**: [`publishing.md`](./publishing.md)
- Backwards-compatible stub: [`installation.md`](./installation.md)

## Repo docs / policies

- Changelog: [`CHANGELOG.md`](../CHANGELOG.md) (alias: `CHANGELOD.md`)
- Contributing: [`CONTRIBUTING.md`](../CONTRIBUTING.md)
- Security: [`SECURITY.md`](../SECURITY.md)
- Acknowledgments: [`ACKNOWLEDMENTS.md`](../ACKNOWLEDMENTS.md)
- License: [`LICENSE`](../LICENSE)

## Package docs

- UI tokens + theme + common inputs: [`ui-kit/README.md`](../ui-kit/README.md)
- Chat primitives (thread, composer, markdown/json renderers): [`panel-chat/README.md`](../panel-chat/README.md)
- Agent-cycle trace viewer (LLM/tool/observe): [`monitor-flow/README.md`](../monitor-flow/README.md)
- KG + Active Memory explorer (ReactFlow): [`monitor-active-memory/README.md`](../monitor-active-memory/README.md)
- GPU widget (custom element + imperative API): [`monitor-gpu/README.md`](../monitor-gpu/README.md)

## CONTRIBUTING.md

# Contributing

Thanks for helping improve AbstractUIC.

AbstractUIC is a **multi-package repo**: each top-level folder is an npm package. The code is the source of truth; docs should stay anchored to exports and contracts in `src/`.

## Quick start

Requirements:
- Node.js `>=18` (see `engines` in each package)
- npm (workspaces are used at the repo root)

```bash
npm install
```

Build all packages that provide a build script:

```bash
npm run build
```

Run tests (only `@abstractframework/monitor-gpu` currently has automated tests):

```bash
npm test
```

## Development workflow

Most React packages build with `tsc` into `dist/`:
- One-off: `cd <package> && npm run build`
- Watch: `cd <package> && npm run build -- --watch`

See [`docs/development.md`](./docs/development.md).

## Documentation expectations

Documentation entrypoints:
- Root overview: [`README.md`](./README.md)
- Next step: [`docs/getting-started.md`](./docs/getting-started.md)

When changing docs:
- Keep language concise and user-facing.
- Prefer “source-of-truth” references like `*/src/index.ts`, `*/src/types.ts`, or the relevant implementation file.
- Ensure cross-links remain correct (docs should reference other relevant docs).

LLM docs:
- `llms.txt` is a short index for agents.
- `llms-full.txt` is generated. Update it after doc changes:

```bash
python scripts/generate-llms-full.py
```

## Making changes

1. Create a branch and keep PRs focused.
2. Update or add docs when you change runtime behavior or public exports.
3. Verify:
   - `npm run build`
   - `npm test`
4. If you bump versions, also update [`CHANGELOG.md`](./CHANGELOG.md).

## Related docs

- Docs index: [`docs/README.md`](./docs/README.md)
- Architecture (diagrams): [`docs/architecture.md`](./docs/architecture.md)
- Publishing (maintainers): [`docs/publishing.md`](./docs/publishing.md)
- Security policy: [`SECURITY.md`](./SECURITY.md)

## SECURITY.md

# Security Policy

We take security seriously and appreciate responsible disclosure.

## Reporting a vulnerability

Preferred: use GitHub’s private vulnerability reporting for this repository (Security → “Report a vulnerability”). This keeps the report private while we investigate and prepare a fix.

If private reporting is not available, contact the maintainer via GitHub and **avoid creating a public issue** for sensitive reports.

Please include:
- A clear description of the issue and potential impact
- Steps to reproduce (ideally a minimal PoC)
- Affected package(s) and version(s) (`*/package.json`)
- Any relevant logs, screenshots, or environment details

## Disclosure expectations

- Please do not publicly disclose the issue until we’ve had a chance to release a fix (or agree on a timeline).
- Do not include secrets (tokens, private URLs, internal hostnames) in reports.

## Security notes for users

- `@abstractframework/monitor-gpu` supports Bearer token auth. Avoid putting tokens in URLs and prefer HTTPS in production.
- See security notes in `monitor-gpu/README.md` and integration guidance in [`docs/getting-started.md`](./docs/getting-started.md).

## Related docs

- Getting started: [`docs/getting-started.md`](./docs/getting-started.md)
- API reference: [`docs/api.md`](./docs/api.md)
- Changelog: [`CHANGELOG.md`](./CHANGELOG.md)

## CHANGELOG.md

# Changelog

All notable changes to AbstractUIC are documented in this file.

This project is a **multi-package repository**; versions are currently kept in sync across packages.

## 0.1.2 - 2026-02-05

### Changed

- Documentation polish pass for public release (clearer entrypoints, tighter cross-links, and more actionable install guidance).
- Version bump to reflect the documentation release across packages.

## 0.1.1 - 2026-02-04

### Added

- User-facing documentation set and navigation:
  - `docs/getting-started.md` (entrypoint after `README.md`)
  - `docs/architecture.md` (includes Mermaid diagrams)
  - `docs/api.md` (package API map)
  - `docs/faq.md`
  - `docs/development.md`, `docs/publishing.md`, `docs/README.md`
- LLM-oriented docs: `llms.txt` and generated `llms-full.txt` (`scripts/generate-llms-full.py`).

### Changed

- React packages publish **compiled ESM + type declarations** from `dist/` (see `main` / `types` / `exports` in each package’s `package.json`).
- CSS is shipped as explicit package exports and must be imported by the host app:
  - `@abstractframework/ui-kit/theme.css`
  - `@abstractframework/panel-chat/panel_chat.css`
  - `@abstractframework/monitor-flow/agent_cycles.css`
  - `@abstractframework/monitor-active-memory/styles.css`
- `@abstractframework/monitor-gpu` custom element supports `mode: "full" | "icon"` (runtime + types).
- Docs are polished for first-time users (clear entrypoints, cross-links, and npm install examples).

## 0.1.0

- Initial repository snapshot (packages + baseline docs).

## Related docs

- Docs index: [`docs/README.md`](./docs/README.md)
- Publishing (maintainers): [`docs/publishing.md`](./docs/publishing.md)

## ACKNOWLEDMENTS.md

# Acknowledgments

AbstractUIC is built on top of excellent open-source projects and the broader web ecosystem.

## Open-source foundations

- **React** and **React DOM** for UI composition (`react`, `react-dom`)
- **TypeScript** for types and build output (`typescript`)
- **ReactFlow** for graph visualization in `@abstractframework/monitor-active-memory` (`reactflow`)

## Thanks

Thanks to contributors and to the AbstractFramework community for shaping real-world requirements and feedback.

## Related docs

- Docs index: [`docs/README.md`](./docs/README.md)
- Contributing: [`CONTRIBUTING.md`](./CONTRIBUTING.md)

## docs/installation.md

# Installation & Integration

This page is kept for backwards compatibility.

Start here instead:

- [Getting started](./getting-started.md)

## ui-kit/README.md

# @abstractframework/ui-kit

Shared theme tokens + small UI primitives used across AbstractUIC packages and host apps.

This package provides:

- **Theme tokens** (CSS variables + theme classes): `ui-kit/src/theme.css`
- **Theme + typography helpers**: `applyTheme(...)`, `applyTypography(...)`
- **Common inputs**: `AfSelect`, `ThemeSelect`, `ProviderModelSelect`, etc.
- **Icons**: `Icon` (used by `@abstractframework/panel-chat`)

## Install / peer dependencies

This is a React package with peer dependencies on `react@^18` and `react-dom@^18` (see `ui-kit/package.json`).

## Install

- Workspace: add a dependency on `@abstractframework/ui-kit`
- npm (once published): `npm i @abstractframework/ui-kit`

## Usage

Import the theme tokens once in your app:

```ts
import "@abstractframework/ui-kit/theme.css";
```

Apply a theme at runtime (optional):

```ts
import { applyTheme } from "@abstractframework/ui-kit";

applyTheme("dark"); // sets a `theme-*` class on <html>
```

Use UI components:

```tsx
import { ThemeSelect, Icon } from "@abstractframework/ui-kit";
```

## Exported API

See `ui-kit/src/index.ts` for the authoritative export list.

## Related docs

- Getting started: [`docs/getting-started.md`](../docs/getting-started.md)
- API reference: [`docs/api.md`](../docs/api.md)
- Repo docs index: [`docs/README.md`](../docs/README.md)
- Architecture: [`docs/architecture.md`](../docs/architecture.md)

## panel-chat/README.md

# @abstractframework/panel-chat

Chat UI primitives for AbstractFramework-style UIs: thread rendering, message cards, a composer, and lightweight Markdown/JSON rendering.

## Peer dependencies

Declared in `panel-chat/package.json`:

- `react@^18`, `react-dom@^18`
- `@abstractframework/ui-kit` (icons used by `ChatMessageCard`)

## Install

- Workspace: add a dependency on `@abstractframework/panel-chat`
- npm (once published): `npm i @abstractframework/panel-chat`

## Exported API

See `panel-chat/src/index.ts` for the authoritative export list. Common entry points:

- Components: `ChatThread`, `ChatComposer`, `ChatMessageCard`, `ChatMessageContent`
- Renderers: `Markdown`, `JsonViewer`
- Types: `PanelChatMessage`, `ChatMessage`, `ChatAttachment`, `ChatStat`
- Utils: `chatToMarkdown`, `copyText`, `downloadTextFile`, `tryParseJson`

## Usage (typical)

```tsx
import React, { useState } from "react";
import { ChatThread, ChatComposer, type ChatMessage } from "@abstractframework/panel-chat";

export function ChatView() {
  const [value, setValue] = useState("");
  const [messages, setMessages] = useState<ChatMessage[]>([]);

  return (
    <>
      <ChatThread messages={messages} autoScroll />
      <ChatComposer value={value} onChange={setValue} onSubmit={() => setMessages((m) => [...m, { role: "user", content: value }])} />
    </>
  );
}
```

## Rendering rules

`ChatMessageContent` auto-detects JSON (via `tryParseJson` in `panel-chat/src/utils.ts`) and renders:

- JSON ⇒ `JsonViewer`
- otherwise ⇒ `Markdown` (or your `renderMarkdown` override)

Markdown is intentionally minimal and implemented in `panel-chat/src/markdown.tsx` (headings 1–3, code fences, lists, tables, blockquotes, hr, emphasis, and optional highlighting).

## Styling & theming

- Import CSS in your app entrypoint (recommended):
  - `import "@abstractframework/panel-chat/panel_chat.css";`
  - `import "@abstractframework/ui-kit/theme.css";` (shared tokens)

## Related docs

- Getting started: [`docs/getting-started.md`](../docs/getting-started.md)
- API reference: [`docs/api.md`](../docs/api.md)
- Architecture: [`docs/architecture.md`](../docs/architecture.md)

## monitor-flow/README.md

# @abstractframework/monitor-flow

React components to inspect **agent execution cycles** (think → act → observe) from per-effect trace records.

## What you get

Authoritative exports live in `monitor-flow/src/index.ts`:

- `AgentCyclesPanel` (+ types `TraceItem`, `TraceStep`)
- `JsonViewer`
- `build_agent_trace` (+ `LedgerRecordItem`, `StepRecordLike`)

## Peer dependencies

Declared in `monitor-flow/package.json`:

- `react@^18`, `react-dom@^18`

## Install

- Workspace: add a dependency on `@abstractframework/monitor-flow`
- npm (once published): `npm i @abstractframework/monitor-flow`

## Expected data

`AgentCyclesPanel` expects `TraceItem[]` (see `monitor-flow/src/AgentCyclesPanel.tsx`):

```ts
type TraceItem = {
  id: string;
  runId: string;
  nodeId: string;
  ts?: string;
  status: string;
  step: Record<string, unknown>;
};
```

Cycles start whenever `step.effect.type === "llm_call"` (see the cycle builder in `monitor-flow/src/AgentCyclesPanel.tsx`).

## Usage

If you already have `TraceItem[]`, pass it directly:

```tsx
import { AgentCyclesPanel } from "@abstractframework/monitor-flow";

<AgentCyclesPanel items={items} />;
```

If you have “ledger-like” records, adapt them with `build_agent_trace`:

```tsx
import { AgentCyclesPanel, build_agent_trace } from "@abstractframework/monitor-flow";

const { items } = build_agent_trace(ledgerItems, { run_id: "run_123" });
<AgentCyclesPanel items={items} />;
```

## Styling

Import CSS in your app entrypoint (recommended):

- `import "@abstractframework/monitor-flow/agent_cycles.css";`
- `import "@abstractframework/ui-kit/theme.css";` (shared tokens)

## Related docs

- Getting started: [`docs/getting-started.md`](../docs/getting-started.md)
- API reference: [`docs/api.md`](../docs/api.md)
- Architecture: [`docs/architecture.md`](../docs/architecture.md)

## monitor-active-memory/README.md

# @abstractframework/monitor-active-memory

ReactFlow-based explorer for **Knowledge Graph assertions** (`KgAssertion`) and the derived **Active Memory** text.

## What you get

- `KgActiveMemoryExplorer` component (see `monitor-active-memory/src/KgActiveMemoryExplorer.tsx`)
- Graph/layout utilities (see `monitor-active-memory/src/graph.ts`):
  - `buildKgGraph`, `shortestPath`
  - `buildKgLayout` + force-layout helpers (`initForceSimulation`, `stepForceSimulation`, …)
- Types / contracts (see `monitor-active-memory/src/types.ts`):
  - `KgAssertion`, `KgQueryParams`, `KgQueryResult`

## Peer dependencies

Declared in `monitor-active-memory/package.json`:

- `react@^18`, `react-dom@^18`
- `reactflow@^11`

## Install

- Workspace: add a dependency on `@abstractframework/monitor-active-memory`
- npm (once published): `npm i @abstractframework/monitor-active-memory`

## Usage

```tsx
import { KgActiveMemoryExplorer, type KgAssertion } from "@abstractframework/monitor-active-memory";

const items: KgAssertion[] = [];

export function MemoryView() {
  return (
    <KgActiveMemoryExplorer
      title="Active Memory"
      items={items}
      activeMemoryText=""
      onQuery={async (params) => {
        // Your host decides how to fetch/search KG assertions.
        return { ok: true, items: [], active_memory_text: "" };
      }}
    />
  );
}
```

## Key props (host integration points)

Authoritative prop types live in `monitor-active-memory/src/KgActiveMemoryExplorer.tsx` (`KgActiveMemoryExplorerProps`).

- `items: KgAssertion[]` (required)
- `activeMemoryText?: string`
- `onQuery?: (params: KgQueryParams) => Promise<KgQueryResult>` (enables the query UI)
- `queryMode?: "override" | "replace"` (how query results interact with `items`)
- `onItemsReplace?: (items, meta) => void` (used when `queryMode === "replace"`)
- `onOpenSpan?` / `onOpenTranscript?` (optional host navigation hooks)

## Layout persistence

The component can persist per-view layouts in `localStorage` under key `abstractuic_amx_saved_layouts_v1` (see `monitor-active-memory/src/KgActiveMemoryExplorer.tsx`).

## CSS

- Import CSS in your app entrypoint (recommended):

```ts
import "@abstractframework/monitor-active-memory/styles.css";
import "@abstractframework/ui-kit/theme.css"; // shared tokens (optional but recommended)
```

- ReactFlow base styles are **not** included. In your app:

```ts
import "reactflow/dist/style.css";
```

## Related docs

- Getting started: [`docs/getting-started.md`](../docs/getting-started.md)
- API reference: [`docs/api.md`](../docs/api.md)
- Architecture: [`docs/architecture.md`](../docs/architecture.md)

## monitor-gpu/README.md

# @abstractframework/monitor-gpu

Small, dependency-free GPU utilization widget that renders a mini histogram and polls a secured backend endpoint.

In AbstractFramework deployments, the default backend endpoint is AbstractGateway:
- `GET /api/gateway/host/metrics/gpu`
- Auth: `Authorization: Bearer <token>`

## Install

- Workspace: add a dependency on `@abstractframework/monitor-gpu`
- npm (once published): `npm i @abstractframework/monitor-gpu`

## Usage (Custom Element)

```js
import { registerMonitorGpuWidget } from "@abstractframework/monitor-gpu";

registerMonitorGpuWidget(); // defines <monitor-gpu>

const el = document.createElement("monitor-gpu");
el.baseUrl = "http://localhost:8080"; // optional (defaults to same-origin)
el.token = "your-gateway-token"; // or el.getToken = async () => ...
el.tickMs = 1500;
el.historySize = 20;
el.mode = "full"; // "full" | "icon"
document.body.appendChild(el);
```

You can also set the non-secret options via attributes:

```html
<monitor-gpu base-url="http://localhost:8080" tick-ms="1500" history-size="20" mode="icon"></monitor-gpu>
```

## Usage (Imperative helper)

```js
import { createMonitorGpuWidget } from "@abstractframework/monitor-gpu";

const widget = createMonitorGpuWidget(document.querySelector("#gpu"), {
  baseUrl: "http://localhost:8080",
  token: "your-gateway-token",
  tickMs: 1500,
  historySize: 20,
});

// later
widget.destroy();
```

## Backend contract (AbstractGateway)

The widget treats the GPU metrics payload as “supported” unless `supported === false` and extracts utilization via `extractUtilizationGpuPct(payload)`:

- `payload.utilization_gpu_pct` (number) **or**
- `payload.gpus[][].utilization_gpu_pct` (numbers; averaged)

Minimal examples:

```json
{ "supported": true, "utilization_gpu_pct": 23.0 }
```

```json
{ "supported": true, "gpus": [{ "utilization_gpu_pct": 10.0 }, { "utilization_gpu_pct": 36.0 }] }
```

If `supported=false`, the widget shows `N/A`.

## Security notes
- Do not pass tokens in URLs.
- For cross-origin usage, ensure `ABSTRACTGATEWAY_ALLOWED_ORIGINS` includes your UI origin (and serve behind HTTPS in production).

## Tests

```bash
cd monitor-gpu
npm test
```

## Related docs

- Getting started: [`docs/getting-started.md`](../docs/getting-started.md)
- API reference: [`docs/api.md`](../docs/api.md)
- Architecture: [`docs/architecture.md`](../docs/architecture.md)

## LICENSE

MIT License

Copyright (c) 2026 Laurent-Philippe Albou

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
